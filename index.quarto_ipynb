{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Market Research\"\n",
        "execute: \n",
        "  freeze: false\n",
        "  python: .venv/bin/python\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "This page contains an outline of the topics, content, and assignments for the semester. Note that this schedule will be updated as the semester progresses and the timeline of topics and assignments might be updated throughout the semester.\n"
      ],
      "id": "ff2f4839"
    },
    {
      "cell_type": "code",
      "metadata": {
        "message": false
      },
      "source": [
        "#| echo: false\n",
        "#| warning: false\n",
        "import pandas as pd\n",
        "from great_tables import GT\n",
        "import requests\n",
        "from dotenv import load_dotenv\n",
        "import os\n",
        "from datetime import datetime\n",
        "\n",
        "# Load environment variables from .env file\n",
        "load_dotenv()\n",
        "\n",
        "# Get API key and spreadsheet ID from environment variables\n",
        "API_KEY = os.getenv(\"GOOGLE_SHEETS_API_KEY\")\n",
        "SPREADSHEET_ID = os.getenv(\"SPREADSHEET_ID\")\n",
        "SHEET_NAME = os.getenv(\"SHEET_NAME\", \"\")  # Try to get sheet name from env\n",
        "\n",
        "def get_sheet_names():\n",
        "    \"\"\"Get a list of sheet names in the spreadsheet\"\"\"\n",
        "    if not API_KEY or not SPREADSHEET_ID:\n",
        "        return []\n",
        "    \n",
        "    url = f\"https://sheets.googleapis.com/v4/spreadsheets/{SPREADSHEET_ID}?key={API_KEY}\"\n",
        "    try:\n",
        "        response = requests.get(url)\n",
        "        if response.status_code != 200:\n",
        "            return []\n",
        "        \n",
        "        data = response.json()\n",
        "        sheets = data.get('sheets', [])\n",
        "        return [sheet['properties']['title'] for sheet in sheets]\n",
        "    except Exception:\n",
        "        return []\n",
        "\n",
        "# Determine the sheet name to use\n",
        "if not SHEET_NAME:\n",
        "    sheet_names = get_sheet_names()\n",
        "    if sheet_names:\n",
        "        SHEET_NAME = sheet_names[0]  # Use the first sheet if available\n",
        "    else:\n",
        "        SHEET_NAME = \"\"  # Will try without sheet name\n",
        "\n",
        "# Construct the range with sheet name if available\n",
        "if SHEET_NAME:\n",
        "    RANGE_NAME = f\"{SHEET_NAME}!A1:G100\"\n",
        "else:\n",
        "    RANGE_NAME = \"A1:G100\"  # Try with default sheet\n",
        "\n",
        "print(f\"Using range: {RANGE_NAME}\")\n",
        "\n",
        "# Call the Sheets API\n",
        "url = f\"https://sheets.googleapis.com/v4/spreadsheets/{SPREADSHEET_ID}/values/{RANGE_NAME}?key={API_KEY}\"\n",
        "print(f\"Connecting to Google Sheets API...\")\n",
        "response = requests.get(url)\n",
        "\n",
        "# Add error handling to diagnose issues\n",
        "if response.status_code != 200:\n",
        "    print(f\"Error: API request failed with status code {response.status_code}\")\n",
        "    \n",
        "    # Special handling for permission error\n",
        "    if response.status_code == 403 and \"PERMISSION_DENIED\" in response.text:\n",
        "        print(\"\\nPERMISSION ERROR: The API key doesn't have permission to access this spreadsheet.\")\n",
        "        print(\"To fix this issue, you need to make your spreadsheet publicly accessible:\")\n",
        "        print(\"1. Open your spreadsheet in Google Sheets\")\n",
        "        print(\"2. Click 'Share' button in the top right\")\n",
        "        print(\"3. Click 'Change to anyone with the link'\")\n",
        "        print(\"4. Make sure 'Viewer' is selected\")\n",
        "        print(\"5. Click 'Done'\")\n",
        "        \n",
        "        # Create a placeholder table with error message\n",
        "        df = pd.DataFrame({\n",
        "            'week': [''],\n",
        "            'date': [datetime.now()],\n",
        "            'topic': ['Error loading schedule from Google Sheets. Please check the console output for details.'],\n",
        "            'prepare': [''],\n",
        "            'materials': [''],\n",
        "            'due': [''],\n",
        "        })\n",
        "    elif response.status_code == 400 and \"Unable to parse range\" in response.text:\n",
        "        print(\"\\nSHEET NAME ERROR: The sheet name doesn't exist in the spreadsheet.\")\n",
        "        print(\"Check your spreadsheet and update the SHEET_NAME in your .env file.\")\n",
        "        print(f\"Available sheets: {', '.join(get_sheet_names()) or 'Could not retrieve'}\")\n",
        "        \n",
        "        # Create a placeholder table with error message\n",
        "        df = pd.DataFrame({\n",
        "            'week': [''],\n",
        "            'date': [datetime.now()],\n",
        "            'topic': ['Error: Invalid sheet name. Check the console output for details.'],\n",
        "            'prepare': [''],\n",
        "            'materials': [''],\n",
        "            'due': [''],\n",
        "        })\n",
        "    else:\n",
        "        print(f\"Response error: {response.text}\")\n",
        "        # Create a placeholder table\n",
        "        df = pd.DataFrame({\n",
        "            'week': [''],\n",
        "            'date': [datetime.now()],\n",
        "            'topic': ['Error loading schedule. Check console for details.'],\n",
        "            'prepare': [''],\n",
        "            'materials': [''],\n",
        "            'due': [''],\n",
        "        })\n",
        "else:\n",
        "    result = response.json()\n",
        "    # Debug information\n",
        "    print(f\"API connection successful\")\n",
        "    \n",
        "    values = result.get('values', [])\n",
        "    if not values:\n",
        "        print('No data found in the spreadsheet.')\n",
        "        # Create a placeholder table\n",
        "        df = pd.DataFrame({\n",
        "            'week': [''],\n",
        "            'date': [datetime.now()],\n",
        "            'topic': ['No data found in spreadsheet.'],\n",
        "            'prepare': [''],\n",
        "            'materials': [''],\n",
        "            'due': [''],\n",
        "        })\n",
        "    else:\n",
        "        print(f\"Found {len(values)-1} data rows\")\n",
        "        headers = values[0]  # First row is headers\n",
        "        data = values[1:]    # Rest is data\n",
        "        \n",
        "        # Check for inconsistent column counts\n",
        "        expected_column_count = len(headers)\n",
        "        print(f\"Expected {expected_column_count} columns: {headers}\")\n",
        "        \n",
        "        # Fix rows with missing columns by adding empty strings\n",
        "        fixed_data = []\n",
        "        for i, row in enumerate(data):\n",
        "            if len(row) < expected_column_count:\n",
        "                print(f\"Row {i+1} has only {len(row)} columns, adding empty values\")\n",
        "                # Add empty strings for missing columns\n",
        "                fixed_row = row + [''] * (expected_column_count - len(row))\n",
        "                fixed_data.append(fixed_row)\n",
        "            else:\n",
        "                fixed_data.append(row)\n",
        "        \n",
        "        # Create DataFrame with the fixed data\n",
        "        df = pd.DataFrame(fixed_data, columns=headers)\n",
        "        \n",
        "        # Clean up data similar to R code\n",
        "        if 'dow' in df.columns:\n",
        "            df = df.drop(columns=['dow'])\n",
        "        if 'session' in df.columns:\n",
        "            df = df.drop(columns=['session'])\n",
        "        \n",
        "        # Keep the original date strings for display\n",
        "        if 'date' in df.columns:\n",
        "            df['original_date'] = df['date']\n",
        "            \n",
        "            # Check if dates have year component\n",
        "            sample_date = df['date'].iloc[0] if not df['date'].empty else \"\"\n",
        "            has_year = any(str(year) in sample_date for year in range(2000, 2100))\n",
        "            \n",
        "            if not has_year:\n",
        "                # If dates don't have year, add the current year for proper parsing\n",
        "                current_year = datetime.now().year\n",
        "                print(f\"Dates in spreadsheet don't have year component. Adding {current_year} for parsing.\")\n",
        "                \n",
        "                # For dates like \"Jan. 11\", convert to \"Jan. 11, 2024\" format\n",
        "                df['date_with_year'] = df['date'].apply(\n",
        "                    lambda x: f\"{x}, {current_year}\" if x and not any(str(y) in x for y in range(2000, 2100)) else x\n",
        "                )\n",
        "                \n",
        "                try:\n",
        "                    # Parse with year added - add dayfirst=True to silence warning\n",
        "                    df['date'] = pd.to_datetime(df['date_with_year'], errors='coerce', dayfirst=True)\n",
        "                    print(\"Successfully parsed dates with added year\")\n",
        "                except Exception as e:\n",
        "                    print(f\"Error parsing dates: {str(e)}\")\n",
        "                    # Keep original strings\n",
        "                    df['date'] = df['original_date']\n",
        "            else:\n",
        "                try:\n",
        "                    # Standard date parsing - add dayfirst=True to silence warning\n",
        "                    df['date'] = pd.to_datetime(df['date'], errors='coerce', dayfirst=True)\n",
        "                except Exception as e:\n",
        "                    print(f\"Error parsing dates: {str(e)}\")\n",
        "                    # Keep original strings if parsing fails\n",
        "                    pass\n",
        "\n",
        "# Replace NaN with empty strings for formatting\n",
        "df = df.fillna(\"\")\n",
        "\n",
        "# Print the actual columns available in the dataframe to help debug\n",
        "print(f\"Available columns in dataframe: {df.columns.tolist()}\")\n",
        "\n",
        "# Create the GT table with similar styling to the R version\n",
        "gt_table = GT(df)\n",
        "\n",
        "# Format the dates - if using original strings, don't format as dates\n",
        "if 'date' in df.columns and pd.api.types.is_datetime64_dtype(df['date']):\n",
        "    # Successfully parsed as dates, use date formatting with a valid date_style\n",
        "    # Use \"day_m\" which corresponds to format like \"Thu, Jan 11\"\n",
        "    gt_table = gt_table.fmt_date(columns=\"date\", date_style=\"day_m\")\n",
        "    print(\"Using date formatting with style 'day_m'\")\n",
        "else:\n",
        "    # Using original strings, no date formatting needed\n",
        "    print(\"Using original date strings\")\n",
        "\n",
        "# Continue with the rest of your table formatting\n",
        "# Only use columns that actually exist in the dataframe\n",
        "actual_columns = df.columns.tolist()\n",
        "\n",
        "# Create column width specification using only columns that exist in the data\n",
        "column_widths = {}\n",
        "if 'week' in actual_columns:\n",
        "    column_widths['week'] = \"45px\"\n",
        "if 'date' in actual_columns:\n",
        "    column_widths['date'] = \"100px\"\n",
        "if 'prepare' in actual_columns:\n",
        "    column_widths['prepare'] = \"100px\"\n",
        "if 'topic' in actual_columns:\n",
        "    column_widths['topic'] = \"300px\"\n",
        "if 'materials' in actual_columns:\n",
        "    column_widths['materials'] = \"150px\"\n",
        "if 'due' in actual_columns:\n",
        "    column_widths['due'] = \"300px\"\n",
        "\n",
        "# Create lists of columns for alignment and markdown formatting\n",
        "center_align_cols = [col for col in ['week'] if col in actual_columns]\n",
        "right_align_cols = [col for col in ['date'] if col in actual_columns]\n",
        "left_align_cols = [col for col in ['topic', 'prepare', 'materials', 'due'] if col in actual_columns]\n",
        "markdown_cols = [col for col in ['topic', 'prepare', 'materials', 'due'] if col in actual_columns]\n",
        "\n",
        "# Generate the table with dynamic column references\n",
        "(\n",
        "    gt_table\n",
        "    .cols_align(\n",
        "        align=\"center\",\n",
        "        columns=center_align_cols if center_align_cols else []\n",
        "    )\n",
        "    .cols_align(\n",
        "        align=\"right\",\n",
        "        columns=right_align_cols if right_align_cols else []\n",
        "    )\n",
        "    .cols_align(\n",
        "        align=\"left\",\n",
        "        columns=left_align_cols if left_align_cols else []\n",
        "    )\n",
        "    .fmt_markdown(\n",
        "        columns=markdown_cols if markdown_cols else []\n",
        "    )\n",
        "    .cols_width(\n",
        "        spec=column_widths\n",
        "    )\n",
        "    .cols_label(\n",
        "        **{col: f\"**{col.upper()}**\" for col in actual_columns}\n",
        "    )\n",
        "    .tab_options(\n",
        "        table_font_size=13\n",
        "    )\n",
        "    .opt_row_striping()\n",
        ")"
      ],
      "id": "f593da3d",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/jankirenz/Library/Jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}